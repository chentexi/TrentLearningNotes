## 创建型模式

### 单例模式
#### 饿汉式(静态常量)

![饿汉式单例.png](http://ww1.sinaimg.cn/large/0068QeGHgy1ga0oa1yxc0j30dy06hq3e.jpg)


#### 双重锁检查懒汉式
![双重锁检查.png](http://ww1.sinaimg.cn/large/0068QeGHgy1ga0ob004yjj30dz09tgmd.jpg)


#### 静态内部类
- 这种方式采用了类装载的机制来保证初始化实例时只有一个线程
- 静态内部类方式在Single2类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingleInstance类，从而完成Singleton的实例化
- 类的静态属性只会在第一次加载类的时候初始化，所以在这里， JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的
- 避免了线程不安全，利用静态内部类特点实现延迟加载，效率高

![静态内部类.png](http://ww1.sinaimg.cn/large/0068QeGHgy1ga0obsymamj30gr07qmxs.jpg)


#### 枚举类
- 借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象

![枚举类单例.png](http://ww1.sinaimg.cn/large/0068QeGHgy1ga0oe9j95fj30d708a3z2.jpg)


### 简单工厂模式
- 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行
- 在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象

### 优点和缺点
- 一个调用者想创建一个对象，只要知道其名称就可以了。
- 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
- 屏蔽产品的具体实现，调用者只关心产品的接口。
- 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，

#### 使用场景    
- 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。
- 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。

![简单工厂模式.png](http://ww1.sinaimg.cn/large/0068QeGHgy1ga0oifqrq6j30hr0ycn1d.jpg)
      
      
### 工厂方法模式
- 定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。
- 工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。

![工厂方法模式](http://ww1.sinaimg.cn/large/0068QeGHgy1ga0on89w23j30dt0dkjsk.jpg)


### 抽象工厂模式
- 抽象工厂模式是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
- 在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

![抽象工厂模式.png](http://ww1.sinaimg.cn/large/0068QeGHgy1ga0opvrospj30de0kvjt9.jpg)


### 原型模式
- 原型模式是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型， 创建新的对象
- 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节
- 工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()
- 形象的理解：孙大圣拔出猴毛， 变出其它孙大圣

#### 浅拷贝和深拷贝
- 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
- 对于数据类型是引用数据类型的成员变量,比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。
- 因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值
- 深拷贝实现方式1：重写clone方法来实现深拷贝
- 深拷贝实现方式2：通过对象序列化实现深拷贝(推荐)

#### 注意事项和细节
- 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
- 不用重新初始化对象，而是动态地获得对象运行时的状态
- 如果原始对象发生变化(增加或者减少属性)，其它克隆对象的也会发生相应的变化，无需修改代码
- 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则

![原型模式.png](http://ww1.sinaimg.cn/large/0068QeGHgy1ga0or4pgh5j30kh0i140i.jpg)


### 建造者模式
- 建造者模式又叫生成器模式，是一种对象构建模式
- 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节
- java.lang.StringBuilder中的建造者模式即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由AbstractStringBuilder完成,而StringBuilder 继承了 AbstractStringBuilder

![建造者模式.png](http://ww1.sinaimg.cn/large/0068QeGHgy1ga0p7am8e0j30li120gr1.jpg)
